#! /bin/sh /usr/share/dpatch/dpatch-run
## 55_fix_ipc_offset_calc_for_direct_plugins.dpatch by Daniel T Chen <crimsun@ubuntu.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Fix ipc offset calculation for direct plugins and add more accurate
## DP: description to x24 formats.
## DP: http://hg-mirror.alsa-project.org/alsa-lib?cs=6cd52c577e46;style=raw

@DPATCH@
diff -urNad alsa-lib-1.0.13~/include/pcm.h alsa-lib-1.0.13/include/pcm.h
--- alsa-lib-1.0.13~/include/pcm.h	2006-09-29 07:42:55.000000000 -0400
+++ alsa-lib-1.0.13/include/pcm.h	2007-02-04 19:02:54.000000000 -0500
@@ -120,13 +120,13 @@
 	SND_PCM_FORMAT_U16_LE,
 	/** Unsigned 16 bit Big Endian */
 	SND_PCM_FORMAT_U16_BE,
-	/** Signed 24 bit Little Endian */
+	/** Signed 24 bit Little Endian using low three bytes in 32-bit word */
 	SND_PCM_FORMAT_S24_LE,
-	/** Signed 24 bit Big Endian */
+	/** Signed 24 bit Big Endian using low three bytes in 32-bit word */
 	SND_PCM_FORMAT_S24_BE,
-	/** Unsigned 24 bit Little Endian */
+	/** Unsigned 24 bit Little Endian using low three bytes in 32-bit word */
 	SND_PCM_FORMAT_U24_LE,
-	/** Unsigned 24 bit Big Endian */
+	/** Unsigned 24 bit Big Endian using low three bytes in 32-bit word */
 	SND_PCM_FORMAT_U24_BE,
 	/** Signed 32 bit Little Endian */
 	SND_PCM_FORMAT_S32_LE,
diff -urNad alsa-lib-1.0.13~/src/pcm/pcm_direct.c alsa-lib-1.0.13/src/pcm/pcm_direct.c
--- alsa-lib-1.0.13~/src/pcm/pcm_direct.c	2006-09-29 07:42:56.000000000 -0400
+++ alsa-lib-1.0.13/src/pcm/pcm_direct.c	2007-02-04 19:02:54.000000000 -0500
@@ -1424,12 +1424,12 @@
 						int hop)
 {
 	snd_config_iterator_t i, next;
+	snd_config_t *pcm_conf;
 	int err;
 	long card = 0, device = 0, subdevice = 0;
 	const char *str;
 
 	if (snd_config_get_string(sconf, &str) >= 0) {
-		snd_config_t *pcm_conf;
 		if (hop > SND_CONF_MAX_HOPS) {
 			SNDERR("Too many definition levels (looped?)");
 			return -EINVAL;
@@ -1446,6 +1446,21 @@
 		return err;
 	}
 
+#if 0	/* for debug purposes */
+	{
+		snd_output_t *out;
+		snd_output_stdio_attach(&out, stderr, 0);
+		snd_config_save(sconf, out);
+		snd_output_close(out);
+	}
+#endif
+
+	if (snd_config_search(sconf, "slave", &pcm_conf) >= 0 &&
+	    snd_config_search(pcm_conf, "pcm", &pcm_conf) >= 0)
+		return _snd_pcm_direct_get_slave_ipc_offset(root, pcm_conf,
+							    direction,
+							    hop + 1);
+
 	snd_config_for_each(i, next, sconf) {
 		snd_config_t *n = snd_config_iterator_entry(i);
 		const char *id, *str;
@@ -1629,7 +1644,7 @@
 		SNDERR("Unknown field %s", id);
 		return -EINVAL;
 	}
-	if (! rec->slave) {
+	if (!rec->slave) {
 		SNDERR("slave is not defined");
 		return -EINVAL;
 	}
@@ -1639,7 +1654,7 @@
 	}
 	if (ipc_key_add_uid)
 		rec->ipc_key += getuid();
-	err = snd_pcm_direct_get_slave_ipc_offset(root, rec->slave, stream);
+	err = snd_pcm_direct_get_slave_ipc_offset(root, conf, stream);
 	if (err < 0)
 		return err;
 	rec->ipc_key += err;
