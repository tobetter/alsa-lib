Index: alsa-lib-1.0.20/src/pcm/pcm_ioplug.c
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_ioplug.c	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_ioplug.c	2009-09-06 10:31:01.000000000 -0400
@@ -442,7 +442,7 @@
 	int err;
 	
 	if (io->data->state != SND_PCM_STATE_PREPARED)
-		return -EBUSY;
+		return -EBADFD;
 
 	err = io->data->callback->start(io->data);
 	if (err < 0)
Index: alsa-lib-1.0.20/src/pcm/pcm_meter.c
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_meter.c	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_meter.c	2009-09-06 10:31:01.000000000 -0400
@@ -46,7 +46,7 @@
 struct _snd_pcm_scope {
 	int enabled;
 	char *name;
-	snd_pcm_scope_ops_t *ops;
+	const snd_pcm_scope_ops_t *ops;
 	void *private_data;
 	struct list_head list;
 };
@@ -960,7 +960,7 @@
  * \param scope PCM meter scope
  * \param val callbacks
  */
-void snd_pcm_scope_set_ops(snd_pcm_scope_t *scope, snd_pcm_scope_ops_t *val)
+void snd_pcm_scope_set_ops(snd_pcm_scope_t *scope, const snd_pcm_scope_ops_t *val)
 {
 	scope->ops = val;
 }
Index: alsa-lib-1.0.20/src/pcm/pcm_mmap_emul.c
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_mmap_emul.c	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_mmap_emul.c	2009-09-06 10:31:01.000000000 -0400
@@ -43,6 +43,7 @@
 	unsigned int mmap_emul :1;
 	snd_pcm_uframes_t hw_ptr;
 	snd_pcm_uframes_t appl_ptr;
+	snd_pcm_uframes_t start_threshold;
 } mmap_emul_t;
 
 /*
@@ -203,6 +204,24 @@
 	return err;
 }
 
+static int snd_pcm_mmap_emul_sw_params(snd_pcm_t *pcm,
+				       snd_pcm_sw_params_t *params)
+{
+	mmap_emul_t *map = pcm->private_data;
+	int err;
+
+	map->start_threshold = params->start_threshold;
+
+	/* HACK: don't auto-start in the slave PCM */
+	params->start_threshold = pcm->boundary;
+	err = snd_pcm_generic_sw_params(pcm, params);
+	if (err < 0)
+		return err;
+	/* restore the value for this PCM */
+	params->start_threshold = map->start_threshold;
+	return err;
+}
+
 static int snd_pcm_mmap_emul_prepare(snd_pcm_t *pcm)
 {
 	mmap_emul_t *map = pcm->private_data;
@@ -254,13 +273,18 @@
 	snd_pcm_uframes_t offset;
 	snd_pcm_sframes_t size;
 
+	/* HACK: don't start stream automatically at commit in mmap mode */
+	pcm->start_threshold = pcm->boundary;
+
 	size = map->appl_ptr - *slave->appl.ptr;
 	if (size < 0)
 		size += pcm->boundary;
-	if (!size)
-		return 0;
-	offset = *slave->appl.ptr % pcm->buffer_size;
-	return snd_pcm_write_mmap(pcm, offset, size);
+	if (size) {
+		offset = *slave->appl.ptr % pcm->buffer_size;
+		size = snd_pcm_write_mmap(pcm, offset, size);
+	}
+	pcm->start_threshold = map->start_threshold; /* restore */
+	return size;
 }
 
 /* read the available chunk on the slave PCM to mmap buffer */
@@ -335,7 +359,7 @@
 	.hw_refine = snd_pcm_mmap_emul_hw_refine,
 	.hw_params = snd_pcm_mmap_emul_hw_params,
 	.hw_free = snd_pcm_generic_hw_free,
-	.sw_params = snd_pcm_generic_sw_params,
+	.sw_params = snd_pcm_mmap_emul_sw_params,
 	.channel_info = snd_pcm_generic_channel_info,
 	.dump = snd_pcm_mmap_emul_dump,
 	.nonblock = snd_pcm_generic_nonblock,
Index: alsa-lib-1.0.20/src/pcm/pcm_dmix_i386.h
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_dmix_i386.h	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_dmix_i386.h	2009-09-06 10:31:01.000000000 -0400
@@ -400,8 +400,8 @@
 		"\tmovzwl (%%esi), %%ecx\n"
 		"\tmovl (%%ebx), %%edx\n"
 		"\tsall $16, %%eax\n"
+		"\torl %%eax, %%ecx\n"
 		"\t" LOCK_PREFIX "btsw $0, (%%edi)\n"
-		"\tleal (%%ecx,%%eax,1), %%ecx\n"
 		"\tjc 2f\n"
 		"\t" XSUB " %%edx, %%ecx\n"
 		"2:"
Index: alsa-lib-1.0.20/src/pcm/pcm_dmix_x86_64.h
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_dmix_x86_64.h	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_dmix_x86_64.h	2009-09-06 10:31:01.000000000 -0400
@@ -284,11 +284,11 @@
 		 *   *sum += sample;
 		 */
 		"\tmovsbl 2(%%rsi), %%eax\n"
-		"\tmovswl (%%rsi), %%ecx\n"
+		"\tmovzwl (%%rsi), %%ecx\n"
 		"\tmovl (%%rbx), %%edx\n"
 		"\tsall $16, %%eax\n"
+		"\torl %%eax, %%ecx\n"
 		"\t" LOCK_PREFIX "btsw $0, (%%rdi)\n"
-		"\t.byte 0x67, 0x8d, 0x0c, 0x01\n"
 		"\tjc 2f\n"
 		"\t" XSUB " %%edx, %%ecx\n"
 		"2:"
Index: alsa-lib-1.0.20/src/pcm/pcm_hooks.c
===================================================================
--- alsa-lib-1.0.20.orig/src/pcm/pcm_hooks.c	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/pcm/pcm_hooks.c	2009-09-06 10:31:01.000000000 -0400
@@ -43,12 +43,39 @@
 	struct list_head list;
 };
 
+struct snd_pcm_hook_dllist {
+	void *dlobj;
+	struct list_head list;
+};
+
 typedef struct {
 	snd_pcm_generic_t gen;
 	struct list_head hooks[SND_PCM_HOOK_TYPE_LAST + 1];
+	struct list_head dllist;
 } snd_pcm_hooks_t;
 #endif
 
+static int hook_add_dlobj(snd_pcm_t *pcm, void *dlobj)
+{
+	snd_pcm_hooks_t *h = pcm->private_data;
+	struct snd_pcm_hook_dllist *dl;
+
+	dl = malloc(sizeof(*dl));
+	if (!dl)
+		return -ENOMEM;
+
+	dl->dlobj = dlobj;
+	list_add_tail(&dl->list, &h->dllist);
+	return 0;
+}
+
+static void hook_remove_dlobj(struct snd_pcm_hook_dllist *dl)
+{
+	list_del(&dl->list);
+	snd_dlclose(dl->dlobj);
+	free(dl);
+}
+
 static int snd_pcm_hooks_close(snd_pcm_t *pcm)
 {
 	snd_pcm_hooks_t *h = pcm->private_data;
@@ -71,6 +98,10 @@
 			snd_pcm_hook_remove(hook);
 		}
 	}
+	while (!list_empty(&h->dllist)) {
+		pos = h->dllist.next;
+		hook_remove_dlobj(list_entry(pos, struct snd_pcm_hook_dllist, list));
+	}
 	err = snd_pcm_generic_close(pcm);
 	if (err < 0)
 		res = err;
@@ -193,6 +224,7 @@
 	for (k = 0; k <= SND_PCM_HOOK_TYPE_LAST; ++k) {
 		INIT_LIST_HEAD(&h->hooks[k]);
 	}
+	INIT_LIST_HEAD(&h->dllist);
 	err = snd_pcm_new(&pcm, SND_PCM_TYPE_HOOKS, name, slave->stream, slave->mode);
 	if (err < 0) {
 		free(h);
@@ -312,6 +344,7 @@
 	snd_config_iterator_t i, next;
 	int (*install_func)(snd_pcm_t *pcm, snd_config_t *args) = NULL;
 	void *h = NULL;
+
 	if (snd_config_get_type(conf) != SND_CONFIG_TYPE_COMPOUND) {
 		SNDERR("Invalid hook definition");
 		return -EINVAL;
@@ -402,20 +435,26 @@
        _err:
 	if (type)
 		snd_config_delete(type);
-	if (err >= 0) {
-		if (args && snd_config_get_string(args, &str) >= 0) {
-			err = snd_config_search_definition(root, "hook_args", str, &args);
-			if (err < 0)
-				SNDERR("unknown hook_args %s", str);
-			else
-				err = install_func(pcm, args);
-			snd_config_delete(args);
-		} else
+	if (err < 0)
+		return err;
+
+	if (args && snd_config_get_string(args, &str) >= 0) {
+		err = snd_config_search_definition(root, "hook_args", str, &args);
+		if (err < 0)
+			SNDERR("unknown hook_args %s", str);
+		else
 			err = install_func(pcm, args);
+		snd_config_delete(args);
+	} else
+		err = install_func(pcm, args);
+
+	if (err >= 0)
+		err = hook_add_dlobj(pcm, h);
+
+	if (err < 0) {
 		snd_dlclose(h);
-	}
-	if (err < 0)
 		return err;
+	}
 	return 0;
 }
 
Index: alsa-lib-1.0.20/src/conf/cards/USB-Audio.conf
===================================================================
--- alsa-lib-1.0.20.orig/src/conf/cards/USB-Audio.conf	2009-09-06 10:14:02.000000000 -0400
+++ alsa-lib-1.0.20/src/conf/cards/USB-Audio.conf	2009-09-06 10:31:01.000000000 -0400
@@ -40,11 +40,48 @@
 # If a device requires non-standard definitions for front, surround40,
 # surround51, surround71 or iec958, they can be defined here.
 
-# USB-Audio."NoiseBlaster 3000".pcm.surround51 {
-#	@args [ CARD ]
-#	@args.CARD { type string }
-#	...
-# }
+# M-Audio AudioPhile USB:
+# device 0: analog output, digital input
+# device 1: digital output, analog input
+USB-Audio."AudioPhile".pcm.default {
+	@args [ CARD ]
+	@args.CARD { type string }
+	type asym
+	playback.pcm {
+		type plug
+		slave.pcm {
+			type hw
+			card $CARD
+			device 0
+		}
+	}
+	capture.pcm {
+		type plug
+		slave.pcm {
+			@func concat
+			strings [ "dsnoop:DEVICE=1,CARD=" $CARD ]
+		}
+	}
+}
+USB-Audio."AudioPhile".pcm.iec958 {
+	@args [ CARD AES0 AES1 AES2 AES3 ]
+	@args.CARD { type string }
+	@args.AES0 { type integer }
+	@args.AES1 { type integer }
+	@args.AES2 { type integer }
+	@args.AES3 { type integer }
+	type asym
+	playback.pcm {
+		type hw
+		card $CARD
+		device 1
+	}
+	capture.pcm {
+		type hw
+		card $CARD
+		device 0
+	}
+}
 
 
 ################################################################################
Index: alsa-lib-1.0.20/include/pcm.h
===================================================================
--- alsa-lib-1.0.20.orig/include/pcm.h	2009-09-06 10:34:28.000000000 -0400
+++ alsa-lib-1.0.20/include/pcm.h	2009-09-06 10:37:14.000000000 -0400
@@ -1022,7 +1022,8 @@
 int snd_pcm_meter_add_scope(snd_pcm_t *pcm, snd_pcm_scope_t *scope);
 snd_pcm_scope_t *snd_pcm_meter_search_scope(snd_pcm_t *pcm, const char *name);
 int snd_pcm_scope_malloc(snd_pcm_scope_t **ptr);
-void snd_pcm_scope_set_ops(snd_pcm_scope_t *scope, snd_pcm_scope_ops_t *val);
+void snd_pcm_scope_set_ops(snd_pcm_scope_t *scope,
+			   const snd_pcm_scope_ops_t *val);
 void snd_pcm_scope_set_name(snd_pcm_scope_t *scope, const char *val);
 const char *snd_pcm_scope_get_name(snd_pcm_scope_t *scope);
 void *snd_pcm_scope_get_callback_private(snd_pcm_scope_t *scope);
