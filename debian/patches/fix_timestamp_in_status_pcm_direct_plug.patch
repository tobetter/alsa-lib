Index: alsa-lib-1.0.15/src/pcm/pcm_direct.c
===================================================================
--- alsa-lib-1.0.15.orig/src/pcm/pcm_direct.c	2008-03-11 22:46:44.000000000 -0400
+++ alsa-lib-1.0.15/src/pcm/pcm_direct.c	2008-03-11 22:46:59.000000000 -0400
@@ -1001,6 +1001,17 @@
 		return ret;
 	}
 
+	/* set timestamp mode to MMAP
+	 * the slave timestamp is copied appropriately in dsnoop/dmix/dshare
+	 * based on the tstamp_mode of each client
+	 */
+	ret = snd_pcm_sw_params_set_tstamp_mode(spcm, sw_params,
+						SND_PCM_TSTAMP_MMAP);
+	if (ret < 0) {
+		SNDERR("unable to tstamp mode MMAP");
+		return ret;
+	}
+
 	if (dmix->type != SND_PCM_TYPE_DMIX)
 		goto __skip_silencing;
 
Index: alsa-lib-1.0.15/src/pcm/pcm_dmix.c
===================================================================
--- alsa-lib-1.0.15.orig/src/pcm/pcm_dmix.c	2008-03-11 22:46:44.000000000 -0400
+++ alsa-lib-1.0.15/src/pcm/pcm_dmix.c	2008-03-11 22:46:59.000000000 -0400
@@ -420,7 +420,14 @@
 	memset(status, 0, sizeof(*status));
 	status->state = snd_pcm_dmix_state(pcm);
 	status->trigger_tstamp = dmix->trigger_tstamp;
-	status->tstamp = snd_pcm_hw_fast_tstamp(dmix->spcm);
+	if (pcm->tstamp_mode == SND_PCM_TSTAMP_MMAP)
+		status->tstamp = snd_pcm_hw_fast_tstamp(dmix->spcm);
+	else {
+		struct timeval tv;
+		gettimeofday(&tv, 0);
+		status->tstamp.tv_sec = tv.tv_sec;
+		status->tstamp.tv_nsec = tv.tv_usec * 1000L;
+	}
 	status->avail = snd_pcm_mmap_playback_avail(pcm);
 	status->avail_max = status->avail > dmix->avail_max ? status->avail : dmix->avail_max;
 	dmix->avail_max = 0;
Index: alsa-lib-1.0.15/src/pcm/pcm_dshare.c
===================================================================
--- alsa-lib-1.0.15.orig/src/pcm/pcm_dshare.c	2008-03-11 22:46:44.000000000 -0400
+++ alsa-lib-1.0.15/src/pcm/pcm_dshare.c	2008-03-11 22:46:59.000000000 -0400
@@ -229,7 +229,14 @@
 	memset(status, 0, sizeof(*status));
 	status->state = snd_pcm_state(dshare->spcm);
 	status->trigger_tstamp = dshare->trigger_tstamp;
-	status->tstamp = snd_pcm_hw_fast_tstamp(dshare->spcm);
+	if (pcm->tstamp_mode == SND_PCM_TSTAMP_MMAP)
+		status->tstamp = snd_pcm_hw_fast_tstamp(dshare->spcm);
+	else {
+		struct timeval tv;
+		gettimeofday(&tv, 0);
+		status->tstamp.tv_sec = tv.tv_sec;
+		status->tstamp.tv_nsec = tv.tv_usec * 1000L;
+	}
 	status->avail = snd_pcm_mmap_playback_avail(pcm);
 	status->avail_max = status->avail > dshare->avail_max ? status->avail : dshare->avail_max;
 	dshare->avail_max = 0;
Index: alsa-lib-1.0.15/src/pcm/pcm_dsnoop.c
===================================================================
--- alsa-lib-1.0.15.orig/src/pcm/pcm_dsnoop.c	2008-03-11 22:46:45.000000000 -0400
+++ alsa-lib-1.0.15/src/pcm/pcm_dsnoop.c	2008-03-11 22:46:59.000000000 -0400
@@ -175,7 +175,14 @@
 	state = snd_pcm_state(dsnoop->spcm);
 	status->state = state == SND_PCM_STATE_RUNNING ? dsnoop->state : state;
 	status->trigger_tstamp = dsnoop->trigger_tstamp;
-	status->tstamp = snd_pcm_hw_fast_tstamp(dsnoop->spcm);
+	if (pcm->tstamp_mode == SND_PCM_TSTAMP_MMAP)
+		status->tstamp = snd_pcm_hw_fast_tstamp(dsnoop->spcm);
+	else {
+		struct timeval tv;
+		gettimeofday(&tv, 0);
+		status->tstamp.tv_sec = tv.tv_sec;
+		status->tstamp.tv_nsec = tv.tv_usec * 1000L;
+	}
 	status->avail = snd_pcm_mmap_capture_avail(pcm);
 	status->avail_max = status->avail > dsnoop->avail_max ? status->avail : dsnoop->avail_max;
 	dsnoop->avail_max = 0;
